# -*- coding: utf-8 -*-
"""proyecto 4 ArbolesExpancion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ugL2t6sldbK3NocQFNlPOtJzDVDeVmGR
"""



#Se guradan los nodos a utilizar
class Nodo:

    #se generan los vertices y los vecinos  donde v es un veciono y p es el peso 
    def __init__(self, i):
        self.id=i #es la id de los datos
        self.visitado=False
        self.nivel = -1
        self.m_vecinos =[]
        self.vecinos =[] #genera la lista de los vecinos
        self.padre = None #el sacestro
        self.distancia = float('inf')
         
    #Cargo la lista de vecinos que se genera
    def agregarVecino(self, v, p):
        if not v in self.vecinos:
            self.vecinos.append([v, p])
    
    def m_agregarVecino(self, v): # nos inica v el nodo y p el peso del nodo
        if not v in self.m_vecinos:
            self.m_vecinos.append(v)
#-----------------------------------------------------------------------------
class Cilos:

    #se generan los vertices y los vecinos  donde v es un veciono y p es el peso 
    def __init__(self, i):
        self.id=i #es la id de los datos
        self.visitado=False
        self.hojas =[]
        self.padre = None #el sacestro

    def agregarNodos(self, v): # nos inica v el nodo y p el peso del nodo
        if not v in self.hojas:
            self.hojas.append(v)

class PesosW:
    #se generan los vertices y los vecinos  donde v es un veciono y p es el peso 
    def __init__(self, i):
        self.id=i #es la id de los datos
        self.visitado=False
        self.vecinosP =[]
        
    def agregarUniones(self, a, b): # nos inica v el nodo y p el peso del nodo
        if not a in self.vecinosP:
            self.vecinosP.append([a,b]) 
#-----------------------------------------------------------------------------
    
class Grafo:
    def __init__(self):
        self.vertices = {} #key: id == key, lista identicadores del nodo que son sus vecinos
        self.diccionarioPesos ={}
        self.ramas  = {}

    #Genero la lista de nodos que tengo
    def agregaNodo(self, id):
        if id not in self.vertices:
            self.vertices[id]= Nodo(id)
        
    ##########################################################
    def agregarAristas(self, a, b, p): #contrulle la arista y les proporciona el peso p
        if a in self.vertices and b in self.vertices:
            
            self.vertices[a].agregarVecino(b, p) #cargamos los nodos con sus vecinos y pesos 
            self.vertices[b].agregarVecino(a, p)

    #______________ kruska _______________________
    def agregaPesos(self, id):
        if id not in self.diccionarioPesos:
            self.diccionarioPesos[id]= PesosW(id)
    
    def seleccionArista(self, a, b, p): #contrulle la arista y les proporciona el peso p 
        self.diccionarioPesos[p].agregarUniones(a, b)
    
    def agregaVert(self, id):
        if id not in self.ramas:
            self.ramas[id]= Cilos(id)
    
    def agregarAris(self, a, b): #contrulle la arista y les proporciona el peso 
        if a in self.ramas and b in self.ramas:
            self.ramas[a].agregarNodos(b)
            self.ramas[b].agregarNodos(a)

    def dfs(self, r, storefs):
        
        if r in self.ramas:          
            self.ramas[r].visitado = True
            for nodo in self.ramas[r].hojas:               
                if self.ramas[nodo].visitado == False:
                    self.ramas[nodo].padre = r
                    storefs.append( nodo)
                    self.dfs(nodo, storefs)

        
        return storefs
    
    def kruska(self, lista, sentido):
        g = Grafo()

        lista_peso = []
        for i in range(0, len(lista)): #Se recibe un grafo con pesos
            lista_peso.append(lista[i][2]) #separamos los pesos para formar una lista 
        
        if sentido == True:
            lista_peso.sort() #se organisa los pesos de menor a mayor
        elif sentido == False:
            lista_peso.sort(reverse=True) #se organisa los pesos de menor a mayor
        
        no_repetido =[] #Se llenan la lista con datos no repetidos
        repetido = [] #Se llenan la lista con datos repetidos
        agrupar= []

        #Elimino los datos repetidos de los pesos
        for i in lista_peso: 
            if not i in no_repetido:  
                no_repetido.append(i) #Me quedo un la lista de valores que aun no se han repetido
        
        #Contrullo un diccionario con los peso 
        for i in lista_peso:
            g.agregaPesos(i)

        for i in range(0,len(lista)):
            for j in range(0,3):
                agrupar.append(lista[i][j])
        
        for i in range(0, len(agrupar)-1, 3):
            g.seleccionArista(agrupar[i], agrupar[i+1], agrupar[i+2])
    
        candidatos = []
        arbol_pr = []
        repetidos_candidatos = []
        resultado = 0
        pintados = []
        for v in g.diccionarioPesos: 
            storefs = []
            k = list(g.diccionarioPesos[v].vecinosP) 
            
            for i in k:
                
                if i[0] in pintados and i[1] in pintados:

                    for m in self.ramas:
                        self.ramas[m].visitado = False
                    storefs = self.dfs(i[0], storefs)
                        
                    if i[1] not in storefs:
                        if (i[0], i[1], v) not in arbol_pr:
                            arbol_pr.append((i[0], i[1], v))
                            resultado += v
                            self.agregarAris(i[0], i[1])
                else: 
                    if i[0] not in pintados:
                        pintados.append(i[0])
                    if i[1] not in pintados:
                        pintados.append(i[1])
                   
                    self.agregarAris(i[0], i[1])
                    arbol_pr.append((i[0], i[1], v))
                    resultado += v
       
        return (arbol_pr, resultado) 

    #_______________ PRIM ____________________________________ 
    def valorMinimo(self, lista, padre, actual, valorMinimo):
        if len(lista)>0:
            after = padre
            newActual = actual
            for nodo in lista:   
                i = nodo
                for  v in self.vertices[nodo].vecinos:
                    if v[0] not in lista:
                        if valorMinimo > v[1]:                           
                            valorMinimo = v[1]
                            newActual = v[0]
                            after = nodo
                    else:
                        continue
            return (after, newActual,  valorMinimo)

    def prim(self, a):

        if  a in  self.vertices:
            
            #almacena los nodos no actualizados
            noVisitados = []
            nodoVisitados = []  
            arbol = []

            for v in self.vertices:
                noVisitados.append(v)

            pesoMin = self.vertices[a].vecinos[0][1]
            u = self.vertices[a].vecinos[0][0]
            for  v in self.vertices[a].vecinos:
                if pesoMin > v[1]:
                    pesoMin = v[1]
                    u = v[0]
            
            padre = a
            actual = u
            noVisitados.remove(padre)
            nodoVisitados.append(padre)
            self.vertices[actual].padre = padre
            valorPrim = pesoMin
            arbol.append((padre, actual, pesoMin))
            
            while len(noVisitados) - 1 > 0:

                nodoVisitados.append(actual)
                padre = actual
                
                candidatoPeso = []
                s = 1
                while s < len(nodoVisitados) + 1:
                    actual = nodoVisitados[-s]
                    for i in self.vertices[actual].vecinos:
                        if i[0] not in nodoVisitados:
                            candidatoPeso.append(i[1])
                        elif i[0] in nodoVisitados:
                            continue
                    if len(candidatoPeso) > 0:
                        s = len(nodoVisitados) + 1
                        candidatoPeso.sort()
                        for j in self.vertices[actual].vecinos:
                            if candidatoPeso[0] == j[1] and j[0] not in nodoVisitados:
                                padre = actual
                                actual = j[0]
                                pesoMin = j[1]
                                break

                    else:
                        s+=1
                    
                (anterior, actual,  pesoMin) = self.valorMinimo(nodoVisitados, padre, actual, pesoMin) 
                valorPrim +=  pesoMin
                noVisitados.remove(actual)
                if len(noVisitados) == 0:
                    nodoVisitados.append(actual)
                arbol.append((anterior, actual,  pesoMin))

                

        else:
            return False
        return (arbol, valorPrim)

    #############################################################

class Biblioteca:
    
    def __init__(self):
        self.listaAristas = []

    #Modelo Gm,n de malla. Crear m*n nodos. Para el nodo ni,j crear una arista con el nodo ni+1,j
    # y otra con el nodo ni,j+1, para i<m y j<n
    def grafoMalla(self, n, m, dirigido=False):
            
        """
        Genera grafo de malla
        :param m: número de columnas (> 1)
        :param n: número de filas (> 1)
        :param dirigido: el grafo es dirigido?
        :return: grafo generado
        """
        coordenada = []
        coordenadaH = []
        coordenadaV= []
        borrar = []
        vertical = []
        horizontal = [] 
        #Genero cooredenadas de tamaño m*n
        for i in range(0, m):
            for j in range(0, n):
                coordenada.append([i, j])

        #Inido el limite derecho de la maya 
        for fin in range(n-1, len(coordenada), n):
            borrar.append((fin, fin+1))
        
        #Generamos los aristas sobre el lado derecho
        for coordenadaH in range(0, len(coordenada)):
            vertical.append((coordenadaH, coordenadaH+1))
        #eliminamos aritas que no pertenecen a la maya                   
        vetical=list(set(vertical)-set(borrar))
        #generamos la aritas verticales 
        for i in range(0, len(coordenada)):    
            coordenadaV.append((i, i+n))

        #Selecciono las aristas que seran generas para el grafo
        longitud = len(coordenadaV)-n
        s=0
        while s < len(coordenadaV):
            if s == longitud:
                s = len(coordenadaV)
            else:
                horizontal.append(coordenadaV[s])
                s+=1
        self.listaAristas = horizontal + vetical
        
            
    #Modelo Gn,m de Erdös y Rényi. Crear n nodos y elegir uniformemente al azar m distintos pares de distintos vértices.
    def grafoErdosRenyi(self, n, m, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Erdos-Renyi
        :param n: número de nodos (> 0)
        :param m: número de aristas (>= n-1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        aristarepe = []
        s=0
        
        while s < m: #proporciono el la cantidad de aritrias que se puede generar 
            #Selecciono dos nodos al azar 
            u=rd.randint(1, n) 
            v=rd.randint(1, n)
            #Si estan repetidos realizo otro intento
            if u == v:
                s-=1
            elif u != v:
                nod2= u,v
            if nod2 in aristarepe:
                s-=1
            else:
                aristarepe.append((nod2))
            s+=1
        self.listaAristas = aristarepe
        
    #Modelo Gn,p de Gilbert. Crear n nodos y poner una arista entre cada par independiente y uniformemente con probabilidad p.
    def grafoGilbert(self, n, p, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Gilbert
        :param n: número de nodos (> 0)
        :param p: probabilidad de crear una arista (0, 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado"""
    
        l=list(range(n)) #se genera una lista de nodos

        #Se lee el los nodos y se realiza un cilco for
        l = ([(l,j) 
            for l in range(n)   
                for j in range(l)   
                    if rd.random() < p]) #toma la decisicon mediante un promedio si se realiza union o no mediate un true o False
        
        self.listaAristas = l

    #Modelo Gn,r geográfico simple. Colocar n nodos en un rectángulo unitario con coordenadas 
    #uniformes (o normales) y colocar una arista entre cada par que queda en distancia r o menor.
    def grafoGeografico(self, n, r, x, y, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo geográfico simple
        :param n: número de nodos (> 0)
        :param r: distancia máxima para crear un nodo (0, 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        coor = []
        numNodoCoor = []
        for i in range(x):
            for j in range(y):
                coor.append((i, j))

        # Genera el numero numero del nodos y su cooredenada 
        for i in range(0, len(coor)-1): 
            j = i, coor[i]
            numNodoCoor.append(j)

        nodoGPS = [] # coordenadas en el cuadrado (m*m)-1
        listaNodo =[]
        #Genero lista de nodos posibles 
        for i in range(n-1):
            listaNodo.append(i)

        #genero al azar nodos dentro del limiete de mis coordenadas 
        #
        #-------IMPORTANTE-----
        totalNodos =rd.randint(50, n-1)
        s=0
        while s < totalNodos: #selecciono al azar el nodo
                
            nodo = rd.choice(listaNodo)
            tomoNodo = listaNodo.index(nodo)
            nodoGPS.append(nodo)

            del listaNodo[tomoNodo] #elimino para no tener repetidos 

            s+=1

        listaNodoRadio =[]

        #Asigno el nodos seleccionado con su coordenada
        for i in range(0, len(nodoGPS)):
            j=numNodoCoor[nodoGPS[i]]
            listaNodoRadio.append(j)

        s=0
        nodoOrigen = []
        nodoMapa = []
        while s < totalNodos:
            
            #tomo un nodo de listaNodoRadio y lo agrego a nodoOtogen
            nodoOrigen.append(listaNodoRadio[0])
            #Elimino el nodo listaNodoRadio que tome
            del listaNodoRadio[0]
            #se utilizara el metodo de puntos dnetro de un circulo donde nodoOrigen es el nodo del centro 
            # y listaNodoRadio son los nodos cercanos a ese nodo

            for i in range(0, len(listaNodoRadio)):
                rN = ((listaNodoRadio[i][1][0]-nodoOrigen[s][1][0])**2) + ((listaNodoRadio[i][1][1]-nodoOrigen[s][1][1])**2)
                if rN <= r:
                    nodoMapa.append((nodoOrigen[s][0], listaNodoRadio[i][0]))         
            s+=1

        self.listaAristas = nodoMapa

    #Variante del modelo Gn,d Barabási-Albert. Colocar n nodos uno por uno, asignando a cada uno d aristas a vértices distintos de tal manera
    # que la probabilidad de que el vértice nuevo se conecte a un vértice existente v es proporcional a la cantidad de aristas que v tiene 
    # actualmente - los primeros d vértices se conecta todos a todos.
    def grafoBarabasiAlbert(self, n, d, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Barabasi-Albert
        :param n: número de nodos (> 0)
        :param d: grado máximo esperado por cada nodo (> 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        l= n
        m=range(n)

        listaNodos = []
        for i in range(0, len(m)):
            listaNodos.append(i)

        nodoUtiles = []
        listaTemporal = []
        nodoAceptado = []
        nodoRevicion = []
        nodoSeleccionados = []
        s=0
        x=0
        #contrullo tomo cada nodo de la lista
        while s < l: 
            s1 = 0
            for i in listaNodos:
                nodoUtiles.append(i)
            del nodoUtiles[0]

            while s1 < d:

                if s != 0 and s1 == 0:
                    for i  in range(0, len(listaTemporal)):
                        j = listaTemporal[i][1]
                        if j == s:
                            s1+=1
                    
                #reglas de promedio para nueva arista
                if s1 != 0:
                    p = 1-(s1/d)
                else:
                    p = 1
                    c = 0

                # Creo la primera aista
                # Proporciono una probavilidad para unirlos al siguiente nodo o no
                if rd.random() < p: # Si es True lo gurdo
                    if s != nodoUtiles[c]:
                        nodoCandidato = s, nodoUtiles[c] #genero una arista
                        listaTemporal.append(nodoCandidato) #la cargo a una pila
                        nodoSeleccionados.append(s)
                        nodoSeleccionados.append(nodoUtiles[c])
                        del nodoUtiles[c] #elimino 
                    
                else:
                    s1-=1
                    c+=1

                # pregunnro si ya lei todos los nodos del grafo
                if c == len(nodoUtiles):
                    c = 0

                s1+=1
            nodoUtiles = [ ]
            print
            s+=1
        
        self.listaAristas = listaTemporal

    #Modelo Gn Dorogovtsev-Mendes. Crear 3 nodos y 3 aristas formando un triángulo. Después, para cada nodo adicional,
    # se selecciona una arista al azar y se crean aristas entre el nodo nuevo y los extremos de la arista seleccionada. 
    def grafoDorogovtsevMendes(self, n, dirigido=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Barabasi-Albert
        :param n: número de nodos (≥ 3)
        :param dirigido: el grafo es dirigido?
        :return: grafo generado
        """
        
        listaNodo = []
        candidatosNodo = []
        trinagulo = []

        for i in range(n):
            listaNodo.append(i)
        
        # Genero un base para conectrar los otros triagulos 
        s = 0
        while s < 3:
        
            nodo = rd.choice(listaNodo) #selecciono un nodo al hazar
            tomoNodo = listaNodo.index(nodo)
            candidatosNodo.append(nodo) #lista candidato

            del listaNodo[tomoNodo] #Elimino el nodo tomado

            s+=1
        # Construyo el primer triangulos
        trinagulo.append((candidatosNodo[0], candidatosNodo[1]))
        trinagulo.append((candidatosNodo[1], candidatosNodo[2]))
        trinagulo.append((candidatosNodo[0], candidatosNodo[2]))
        #Se lecciono un nodo de los disponibles y lo uno con dos nodos de mi lista de candidatos
        # se elmina el nodo tomado y se continua asta finalizar todos los nodos
        s1 = 0
        while s1 < len(trinagulo):
            if len(listaNodo) == 0:
                s1 = len(trinagulo) #Rompe el ciclo
            else:

                nodoB = rd.choice(listaNodo) #elijo un nodo
                nodoT = listaNodo.index(nodoB) #lo convierto en index para eliminar
                
                arista_Azar = rd.choice(trinagulo)
                
                    
                trinagulo.append((nodoB, arista_Azar[0]))
                trinagulo.append((nodoB, arista_Azar[1]))

                del listaNodo[nodoT]            
        
        self.listaAristas = trinagulo
        print(self.listaAristas)

class Csv:
    
    def tabla(self, listaAristas): ## Se adapta una tabla para cargar los datoa a gephi donde nos muestre el grafo entero
        import pandas as pd
        df = pd.DataFrame(listaAristas)
        df.columns = [ 'Target', 'Source', 'Weight']
        return df
            
    def tabla_id(self, n):
        import pandas as pd
        self.lista_Id = []
        self.recorrido_Costo = []
        for i in range(n):
            self.lista_Id.append((i, i))           
        self.dfw = pd.DataFrame(self.lista_Id)
        self.dfw.columns = [ 'Id', 'Label']

    def archivos(self, opcion, listaAristasPeso, n, arbolPr, arbolKrID, arbolKrRD, listaAristas): #Genero archivo para gephi
        import pandas as pd
        self.c = Csv 
        self.df = self.c.tabla(self, listaAristasPeso)
        self.dfe = self.c.tabla(self, arbolPr)
        self.dfk = self.c.tabla(self, arbolKrID) 
        self.dfr = self.c.tabla(self, arbolKrRD) 
        self.c.tabla_id(self, n)
        
        if opcion == 1:
            self.df.to_csv('100_malla.csv', index=False)
            self.dfw.to_csv('100_malla_Id.csv', index=False)
            self.dfe.to_csv('100_malla_Arbol_Pr.csv', index=False)
            self.dfk.to_csv('100_malla_Arbol_KrID.csv', index=False)
            self.dfr.to_csv('100_malla_Arbol_KrRD.csv', index=False)
            
        elif opcion == 2:
            self.df.to_csv('100_ErdosRenyi.csv', index=False)
            self.dfw.to_csv('100_ErdosRenyi_Id.csv', index=False)
            self.dfk.to_csv('100_ErdosRenyi_Arbol_KrID.csv', index=False)
            self.dfe.to_csv('100_ErdosRenyi_Arbol_Pr.csv', index=False)
            self.dfr.to_csv('100_ErdosRenyi_KrRD.csv', index=False)

        elif opcion == 3:
            self.df.to_csv('100_Gilbert.csv', index=False)
            self.dfw.to_csv('100_Gilbert_Id.csv', index=False)
            self.dfk.to_csv('100_Gilbert_Arbol_KrID.csv', index=False)
            self.dfe.to_csv('100_Gilbert_Arbol_Pr.csv', index=False)
            self.dfr.to_csv('100_Gilbert_Arbol_KrRD.csv', index=False)

        elif opcion == 4:
            self.df.to_csv('100_Geográfico.csv', index=False)
            self.dfw.to_csv('100_Geográfico_Id.csv', index=False)
            self.dfk.to_csv('100_Geográfico_Arbol_KrID.csv', index=False)
            self.dfe.to_csv('100_Geográfico_Arbol_Pr.csv', index=False)
            self.dfr.to_csv('100_Geográfico_Arbol_KrRD.csv', index=False)

        elif opcion == 5:
            self.df.to_csv('100_BarabasiAlbert.csv', index=False)
            self.dfw.to_csv('100_BarabasiAlbert_Id.csv', index=False)
            self.dfk.to_csv('100_BarabasiAlbert_Arbol_KrID.csv', index=False)
            self.dfe.to_csv('100_BarabasiAlbert_Arbol_Pr.csv', index=False)
            self.dfr.to_csv('100_BarabasiAlbert_Arbol_KrRD.csv', index=False)

        elif opcion == 6:
            self.df.to_csv('100_Trinagulo.csv', index=False)
            self.dfw.to_csv('100_Trinagulo_Id.csv', index=False)
            self.dfk.to_csv('100_Trinagulo_Arbol_KrID.csv', index=False)
            self.dfe.to_csv('100_Trinagulo_Arbol_Pr.csv', index=False)
            self.dfr.to_csv('100_Trinagulo_Arbol_KrRD.csv', index=False)

class NodosAristas:
    def __init__(self):
        self.b = Biblioteca()
        self.g = Grafo()       
        self.peso = []
        self.listaDj = []
        self.listaKr = []
          
    def nodoID(self, n, listaAristas):
        import random as rd
        
        #Se prorciona la lista de nodo a la clase nodo
        
        self.listaAristas = listaAristas
        for v in range(n):
            self.g.agregaNodo(v)
        for i in range(n):
            self.g.agregaVert(i)


#_____________________________________DJ_______________________________________

        listaLipia = [] #Elimino los parentecis de la lista 
        
        self.grafo_Peso = []

        for i in self.listaAristas:
            for j in i:
                listaLipia.append(j)

        for i in range(0, len(listaLipia)-1, 2): #Recorro la lista de dos en dos y agrego un nuevo valor que sera el peso 
            p = rd.randint(20, 30)
            self.peso.append((listaLipia[i], listaLipia[i+1], p))

        print('Grafo', '\n', self.peso)
        for i in range(0, len(self.peso)): #Leo la lista con pesos y elimino parenteisis para poder procesarlo
            for j in range(0, 3):    
                self.listaDj.append(self.peso[i][j]) 
       
        for i in range(0, len(self.listaDj)-1, 3): #Agrego los valores para definir la arita y la distancia entre ellos
            self.g.agregarAristas( self.listaDj[i],  self.listaDj[i+1],  self.listaDj[i+2])
            self.grafo_Peso.append(( self.listaDj[i],  self.listaDj[i+1],  self.listaDj[i+2]))
               
        nodoSeleccionado = int(input("\n Ingrese el nodo donde iniciara  arbol prim\n"))      
       
        self.arbolPr = self.g.prim(nodoSeleccionado)
        print('\n El Arbol de Expancion minima Prim es: ', '\n', self.arbolPr[0], '\n', 'El consto minimo Prim:', self.arbolPr[1])
        sentido = True
        (self.arbolKrID, valorKrID) = self.g.kruska(self.grafo_Peso, sentido)
        print('\n El Arbol de Expancion minima kruskaID es: ', '\n', self.arbolKrID,  '\n', 'El consto minimo kruskaID:',valorKrID)
        sentido = False
        (self.arbolKrRD, valorKrRD) = self.g.kruska(self.grafo_Peso, sentido)
        print('\n El Arbol de Expancion minima kruskaRD es: ', '\n', self.arbolKrRD,  '\n', 'El consto minimo kruskaRD:',valorKrRD)
        
#_____________________________________DJ_______________________________________   

class Menu:
    def __init__(self): 
        import random as rd
        self.b = Biblioteca()
        self.g = Grafo()
        self.c = Csv()
        self.nod = NodosAristas()   
    
    def imprimircsv(self, opcion, grafo_Peso, n, arbolPr, arbolKrID, arbolKrRD, listaAristas):
        generaArchivo = int(input("Generar un archivo CSV \n 1. Si \n 2. No \n"))
        if generaArchivo == 1:
            self.c.archivos(opcion, grafo_Peso,n, arbolPr, arbolKrID, arbolKrRD, listaAristas)
        else:
            print('No hay CSV \n ')

    def opcionesMenu(self, opcion): 
        import random as rd
        #////////////////////////////////////////////////////////////////////////7  
        #se obteiene n nodos al azar
        self.n = 100 #rd.randint(0, 5) ########## se indica los nodos al azzar
        while opcion != 0:
            if opcion == 1:
                m=10 #rd.randint(0, 6) #### se indica los nodos m para la malla
                n = self.n*m
                print('Graficar la malla')
                self.b.grafoMalla(self.n, m) 
                self.nod.nodoID(n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, n, self.nod.arbolPr[0], self.nod.arbolKrID, self.nod.arbolKrRD, self.b.listaAristas)
                
            elif opcion == 2:
                m=rd.randint(50, self.n) #### indica el número de aristas para Erdos Renyi 
                print('Graficar la Erdos Renyi')
                self.b.grafoErdosRenyi(self.n, m)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.arbolPr[0], self.nod.arbolKrID, self.nod.arbolKrRD, self.b.listaAristas)

            elif opcion == 3:
                print('Graficar la Gilbert')
                #Se proporciona un promedio 
                p = 0.25
                self.b.grafoGilbert(self.n, p)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.arbolPr[0], self.nod.arbolKrID, self.nod.arbolKrRD, self.b.listaAristas)
                
            elif opcion == 4:
                print('Graficar la Geografico')
                r = int(input("Indique un radio "))
                x = int(input("Indique una longitud x"))
                y = int(input("Indique una altura y"))
                self.b.grafoGeografico(self.n, r, x, y) # es importante generar un cuadrado x y y confome al tamaño de n
                print(self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.arbolPr[0], self.nod.arbolKrID, self.nod.arbolKrRD, self.b.listaAristas)
                
            elif opcion == 5:
                print('Graficar la BarabasiAlbert')
                d = rd.randint(50, self.n-1)
                self.b.grafoBarabasiAlbert(self.n, d)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.arbolPr[0], self.nod.arbolKrID, self.nod.arbolKrRD, self.b.listaAristas)
                
            elif opcion == 6:
                print('Graficar la Dorogovtsev Mendes')
                self.b.grafoDorogovtsevMendes(self.n)   
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.arbolPr[0], self.nod.arbolKrID, self.nod.arbolKrRD, self.b.listaAristas)
                
            elif opcion == 0:
                print('Gracias')
            else:
                print('esa opcion no esta en el menú')
            
            
            opcion = int(input("Menú Principal: \n 1. Graficar la malla \n 2. Graficar la Erdos Renyi \n 3. Graficar la Gilbert \n 4. Graficar la Geografico \n 5. Graficar la BarabasiAlbert \n 6. Graficar la Dorogovtsev Mendes \n 0. Salir \n"))
                        
class Main:
    me = Menu()
    
    opcion = int(input("Menú Principal: \n 1. Graficar la malla \n 2. Graficar la Erdos Renyi \n 3. Graficar la Gilbert \n 4. Graficar la Geografico \n 5. Graficar la BarabasiAlbert \n 6. Graficar la Dorogovtsev Mendes \n 0. Salir \n"))
    if opcion == 0:
        print('Gracias')
    me.opcionesMenu(opcion)
    

Main()